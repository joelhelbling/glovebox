package cmd

import (
	"bufio"
	"fmt"
	"os"
	"os/exec"
	"strings"

	"github.com/fatih/color"
	"github.com/joelhelbling/glovebox/internal/digest"
	"github.com/joelhelbling/glovebox/internal/generator"
	"github.com/joelhelbling/glovebox/internal/profile"
	"github.com/spf13/cobra"
)

var (
	buildForce    bool
	buildGenerate bool
)

var buildCmd = &cobra.Command{
	Use:   "build",
	Short: "Generate Dockerfile and build Docker image",
	Long: `Generate a Dockerfile from your profile snippets and build the Docker image.

If the Dockerfile has been modified since last generation, you'll be prompted
to choose how to proceed.`,
	RunE: runBuild,
}

func init() {
	buildCmd.Flags().BoolVarP(&buildForce, "force", "f", false, "Force regeneration without prompts")
	buildCmd.Flags().BoolVar(&buildGenerate, "generate-only", false, "Only generate Dockerfile, don't build image")
	rootCmd.AddCommand(buildCmd)
}

func runBuild(cmd *cobra.Command, args []string) error {
	cwd, err := os.Getwd()
	if err != nil {
		return fmt.Errorf("getting current directory: %w", err)
	}

	p, err := profile.LoadEffective(cwd)
	if err != nil {
		return err
	}

	if p == nil {
		return fmt.Errorf("no profile found. Run 'glovebox init' first")
	}

	dockerfilePath := "Dockerfile"
	yellow := color.New(color.FgYellow)
	green := color.New(color.FgGreen)

	// Generate new Dockerfile content
	newContent, err := generator.Generate(p.Snippets)
	if err != nil {
		return fmt.Errorf("generating Dockerfile: %w", err)
	}
	newDigest := digest.Calculate(newContent)

	// Check if Dockerfile exists and has been modified
	existingContent, err := os.ReadFile(dockerfilePath)
	dockerfileExists := err == nil

	if dockerfileExists && !buildForce {
		existingDigest := digest.Calculate(string(existingContent))

		// Case 1: Dockerfile matches what we'd generate - no changes needed
		if existingDigest == newDigest {
			green.Println("✓ Dockerfile is already up to date")
			if !buildGenerate {
				return runDockerBuild()
			}
			return nil
		}

		// Case 2: Dockerfile was generated by us but profile changed
		if p.Build.DockerfileDigest != "" && existingDigest == p.Build.DockerfileDigest {
			fmt.Println("Profile has changed since last build.")
			fmt.Println("Regenerating Dockerfile...")
		} else if p.Build.DockerfileDigest != "" {
			// Case 3: Dockerfile was modified externally
			yellow.Println("⚠ Dockerfile has been modified since last generation\n")

			// Show diff
			if err := showDiff(string(existingContent), newContent); err != nil {
				fmt.Printf("(Could not show diff: %v)\n", err)
			}

			// Show instructions for preserving changes
			fmt.Println("\nTo preserve your manual changes:")
			fmt.Println("  1. Create a snippet file in .glovebox/snippets/custom/<name>.yaml")
			fmt.Println("     (or ~/.glovebox/snippets/custom/<name>.yaml for global use)")
			fmt.Println("  2. Add your changes to the appropriate section (apt_packages, run_as_root, etc.)")
			fmt.Println("  3. Run: glovebox add custom/<name>")
			fmt.Println("  4. Run: glovebox build")
			fmt.Println()

			// Prompt for action
			action, err := promptBuildAction()
			if err != nil {
				return err
			}

			switch action {
			case "abort":
				fmt.Println("Aborted.")
				return nil
			case "keep":
				// Update digest to current file, don't regenerate
				p.UpdateBuildInfo(existingDigest)
				if err := p.Save(); err != nil {
					return fmt.Errorf("saving profile: %w", err)
				}
				green.Println("✓ Keeping current Dockerfile and updating digest")
				if !buildGenerate {
					return runDockerBuild()
				}
				return nil
			case "regenerate":
				// Fall through to regenerate
			}
		}
	}

	// Write new Dockerfile
	if err := os.WriteFile(dockerfilePath, []byte(newContent), 0644); err != nil {
		return fmt.Errorf("writing Dockerfile: %w", err)
	}

	// Update profile with new digest
	p.UpdateBuildInfo(newDigest)
	if err := p.Save(); err != nil {
		return fmt.Errorf("saving profile: %w", err)
	}

	green.Printf("✓ Generated Dockerfile (%s)\n", digest.Short(newDigest))

	if buildGenerate {
		return nil
	}

	return runDockerBuild()
}

func promptBuildAction() (string, error) {
	reader := bufio.NewReader(os.Stdin)
	fmt.Print("Proceed? [r]egenerate / [k]eep changes / [a]bort: ")
	input, err := reader.ReadString('\n')
	if err != nil {
		return "", err
	}

	input = strings.TrimSpace(strings.ToLower(input))
	switch input {
	case "r", "regenerate":
		return "regenerate", nil
	case "k", "keep":
		return "keep", nil
	case "a", "abort", "":
		return "abort", nil
	default:
		return "abort", nil
	}
}

func showDiff(existing, new string) error {
	// Create temp files for diff
	existingFile, err := os.CreateTemp("", "dockerfile-existing-*")
	if err != nil {
		return err
	}
	defer os.Remove(existingFile.Name())

	newFile, err := os.CreateTemp("", "dockerfile-new-*")
	if err != nil {
		return err
	}
	defer os.Remove(newFile.Name())

	if _, err := existingFile.WriteString(existing); err != nil {
		return err
	}
	existingFile.Close()

	if _, err := newFile.WriteString(new); err != nil {
		return err
	}
	newFile.Close()

	// Run diff
	cmd := exec.Command("diff", "-u", "--color=always",
		"--label", "Current Dockerfile",
		"--label", "Generated Dockerfile",
		existingFile.Name(), newFile.Name())
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	// diff returns exit code 1 when files differ, which is expected
	cmd.Run()

	return nil
}

func runDockerBuild() error {
	fmt.Println("\nBuilding Docker image...")

	cmd := exec.Command("docker", "build", "-t", "glovebox", ".")
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	if err := cmd.Run(); err != nil {
		return fmt.Errorf("docker build failed: %w", err)
	}

	color.New(color.FgGreen).Println("\n✓ Docker image built successfully")
	return nil
}
