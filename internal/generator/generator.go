package generator

import (
	"fmt"
	"sort"
	"strings"

	"github.com/joelhelbling/glovebox/internal/assets"
	"github.com/joelhelbling/glovebox/internal/mod"
)

// GenerateBase creates a base Dockerfile from a list of mod IDs.
// This is used for the global profile and produces a standalone image.
func GenerateBase(modIDs []string) (string, error) {
	mods, err := mod.LoadMultiple(modIDs)
	if err != nil {
		return "", fmt.Errorf("loading mods: %w", err)
	}

	var b strings.Builder

	// Header
	b.WriteString("# Generated by glovebox - DO NOT EDIT DIRECTLY\n")
	b.WriteString("#\n")
	b.WriteString("# This is the base image. To modify:\n")
	b.WriteString("#   glovebox add <mod>      Add a mod\n")
	b.WriteString("#   glovebox remove <mod>   Remove a mod\n")
	b.WriteString("#   glovebox build          Regenerate this file\n")
	b.WriteString("#\n")
	b.WriteString("# Mods:\n")
	for _, m := range mods {
		b.WriteString(fmt.Sprintf("#   - %s\n", m.Name))
	}
	b.WriteString("\n")

	// Base image
	b.WriteString("FROM ubuntu:24.04\n\n")

	// Avoid interactive prompts
	b.WriteString("# Avoid interactive prompts during package installation\n")
	b.WriteString("ENV DEBIAN_FRONTEND=noninteractive\n\n")

	// Collect and dedupe apt repos
	aptRepos := collectAptRepos(mods)
	if len(aptRepos) > 0 {
		// Need software-properties-common for apt-add-repository
		b.WriteString("# Install software-properties-common for apt-add-repository\n")
		b.WriteString("RUN apt-get update && apt-get install -y software-properties-common && rm -rf /var/lib/apt/lists/*\n\n")

		b.WriteString("# Add APT repositories\n")
		b.WriteString("RUN ")
		for i, repo := range aptRepos {
			if i > 0 {
				b.WriteString(" && \\\n    ")
			}
			b.WriteString(fmt.Sprintf("apt-add-repository %s", repo))
		}
		b.WriteString("\n\n")
	}

	// Collect and dedupe apt packages
	aptPackages := collectAptPackages(mods)
	if len(aptPackages) > 0 {
		b.WriteString("# Install packages\n")
		b.WriteString("RUN apt-get update && apt-get install -y \\\n")
		for i, pkg := range aptPackages {
			b.WriteString(fmt.Sprintf("    %s", pkg))
			if i < len(aptPackages)-1 {
				b.WriteString(" \\\n")
			} else {
				b.WriteString(" \\\n    && rm -rf /var/lib/apt/lists/*\n")
			}
		}
		b.WriteString("\n")
	}

	// Run as root commands (in mod order)
	for _, m := range mods {
		if m.RunAsRoot != "" {
			b.WriteString(fmt.Sprintf("# %s setup (root)\n", m.Name))
			b.WriteString("RUN <<'EOF'\n")
			b.WriteString("set -e\n")
			b.WriteString(strings.TrimSpace(m.RunAsRoot))
			b.WriteString("\nEOF\n\n")
		}
	}

	// Write entrypoint script inline using heredoc
	b.WriteString("# Create entrypoint script\n")
	b.WriteString("RUN cat > /usr/local/bin/entrypoint.sh <<'EOF'\n")
	b.WriteString(strings.TrimSpace(assets.EntrypointScript))
	b.WriteString("\nEOF\n")
	b.WriteString("RUN chmod 755 /usr/local/bin/entrypoint.sh\n\n")

	// Switch to non-root user
	b.WriteString("# Switch to non-root user\n")
	b.WriteString("USER ubuntu\n")
	b.WriteString("WORKDIR /home/ubuntu\n\n")

	// Environment variables - set before run_as_user so mods can use each other's env vars
	// (e.g., neovim needs homebrew's PATH to run `brew install`)
	envVars := collectEnvVars(mods)

	// Always include local bin paths
	b.WriteString("# Ensure local binaries are in PATH\n")
	if pathVal, hasPath := envVars["PATH"]; hasPath {
		// Prepend our paths to the mod-specified PATH
		b.WriteString(fmt.Sprintf("ENV PATH=\"/home/ubuntu/.local/bin:/usr/local/bin:%s\"\n", pathVal))
		delete(envVars, "PATH") // Don't emit again below
	} else {
		b.WriteString("ENV PATH=\"/home/ubuntu/.local/bin:/usr/local/bin:$PATH\"\n")
	}

	if len(envVars) > 0 {
		b.WriteString("# Environment variables from mods\n")
		// Sort keys for deterministic output
		envKeys := make([]string, 0, len(envVars))
		for key := range envVars {
			envKeys = append(envKeys, key)
		}
		sort.Strings(envKeys)
		for _, key := range envKeys {
			b.WriteString(fmt.Sprintf("ENV %s=%s\n", key, envVars[key]))
		}
	}
	b.WriteString("\n")

	// Run as user commands
	for _, m := range mods {
		if m.RunAsUser != "" {
			b.WriteString(fmt.Sprintf("# %s setup (user)\n", m.Name))
			b.WriteString("RUN <<'EOF'\n")
			b.WriteString("set -e\n")
			b.WriteString(strings.TrimSpace(m.RunAsUser))
			b.WriteString("\nEOF\n\n")
		}
	}

	// Working directory
	b.WriteString("# Set working directory for mounted projects\n")
	b.WriteString("WORKDIR /workspace\n\n")

	// Entrypoint and default command
	b.WriteString("# Use entrypoint for container initialization\n")
	b.WriteString("ENTRYPOINT [\"/usr/local/bin/entrypoint.sh\"]\n")

	// Determine default shell
	defaultShell := determineDefaultShell(mods)
	b.WriteString(fmt.Sprintf("CMD [\"%s\"]\n", defaultShell))

	return b.String(), nil
}

// GenerateProject creates a project Dockerfile that extends the base image.
// It only includes project-specific mods (additive to base).
// baseModIDs should contain the mods already installed in the base image,
// so their dependencies won't be redundantly included.
func GenerateProject(modIDs []string, baseModIDs []string) (string, error) {
	mods, err := mod.LoadMultipleExcluding(modIDs, baseModIDs)
	if err != nil {
		return "", fmt.Errorf("loading mods: %w", err)
	}

	var b strings.Builder

	// Header
	b.WriteString("# Generated by glovebox - DO NOT EDIT DIRECTLY\n")
	b.WriteString("#\n")
	b.WriteString("# This extends glovebox:base with project-specific tools.\n")
	b.WriteString("# To modify:\n")
	b.WriteString("#   glovebox add <mod>      Add a mod\n")
	b.WriteString("#   glovebox remove <mod>   Remove a mod\n")
	b.WriteString("#   glovebox build          Regenerate this file\n")
	b.WriteString("#\n")
	if len(mods) > 0 {
		b.WriteString("# Mods:\n")
		for _, m := range mods {
			b.WriteString(fmt.Sprintf("#   - %s\n", m.Name))
		}
	} else {
		b.WriteString("# (no project-specific mods)\n")
	}
	b.WriteString("\n")

	// Extend base image
	b.WriteString("FROM glovebox:base\n\n")

	// Switch to root for installations
	b.WriteString("USER root\n\n")

	// Collect and dedupe apt repos
	aptRepos := collectAptRepos(mods)
	if len(aptRepos) > 0 {
		// Need software-properties-common for apt-add-repository (may already be in base)
		b.WriteString("# Ensure software-properties-common is available for apt-add-repository\n")
		b.WriteString("RUN apt-get update && apt-get install -y software-properties-common && rm -rf /var/lib/apt/lists/*\n\n")

		b.WriteString("# Add APT repositories\n")
		b.WriteString("RUN ")
		for i, repo := range aptRepos {
			if i > 0 {
				b.WriteString(" && \\\n    ")
			}
			b.WriteString(fmt.Sprintf("apt-add-repository %s", repo))
		}
		b.WriteString("\n\n")
	}

	// Collect and dedupe apt packages
	aptPackages := collectAptPackages(mods)
	if len(aptPackages) > 0 {
		b.WriteString("# Install packages\n")
		b.WriteString("RUN apt-get update && apt-get install -y \\\n")
		for i, pkg := range aptPackages {
			b.WriteString(fmt.Sprintf("    %s", pkg))
			if i < len(aptPackages)-1 {
				b.WriteString(" \\\n")
			} else {
				b.WriteString(" \\\n    && rm -rf /var/lib/apt/lists/*\n")
			}
		}
		b.WriteString("\n")
	}

	// Run as root commands (in mod order)
	for _, m := range mods {
		if m.RunAsRoot != "" {
			b.WriteString(fmt.Sprintf("# %s setup (root)\n", m.Name))
			b.WriteString("RUN <<'EOF'\n")
			b.WriteString("set -e\n")
			b.WriteString(strings.TrimSpace(m.RunAsRoot))
			b.WriteString("\nEOF\n\n")
		}
	}

	// Switch back to non-root user
	b.WriteString("# Switch back to non-root user\n")
	b.WriteString("USER ubuntu\n")
	b.WriteString("WORKDIR /home/ubuntu\n\n")

	// Environment variables - set before run_as_user so mods can use each other's env vars
	envVars := collectEnvVars(mods)
	if len(envVars) > 0 {
		b.WriteString("# Environment variables from mods\n")
		// Sort keys for deterministic output
		envKeys := make([]string, 0, len(envVars))
		for key := range envVars {
			envKeys = append(envKeys, key)
		}
		sort.Strings(envKeys)
		for _, key := range envKeys {
			b.WriteString(fmt.Sprintf("ENV %s=%s\n", key, envVars[key]))
		}
		b.WriteString("\n")
	}

	// Run as user commands
	for _, m := range mods {
		if m.RunAsUser != "" {
			b.WriteString(fmt.Sprintf("# %s setup (user)\n", m.Name))
			b.WriteString("RUN <<'EOF'\n")
			b.WriteString("set -e\n")
			b.WriteString(strings.TrimSpace(m.RunAsUser))
			b.WriteString("\nEOF\n\n")
		}
	}

	// Set working directory
	b.WriteString("# Set working directory for mounted projects\n")
	b.WriteString("WORKDIR /workspace\n")

	return b.String(), nil
}

// collectAptRepos gathers unique apt repos from all mods
func collectAptRepos(mods []*mod.Mod) []string {
	seen := make(map[string]bool)
	var result []string
	for _, m := range mods {
		for _, repo := range m.AptRepos {
			if !seen[repo] {
				seen[repo] = true
				result = append(result, repo)
			}
		}
	}
	return result
}

// collectAptPackages gathers unique apt packages from all mods
func collectAptPackages(mods []*mod.Mod) []string {
	seen := make(map[string]bool)
	var result []string
	for _, m := range mods {
		for _, pkg := range m.AptPackages {
			if !seen[pkg] {
				seen[pkg] = true
				result = append(result, pkg)
			}
		}
	}
	return result
}

// collectEnvVars gathers environment variables, later mods override earlier
func collectEnvVars(mods []*mod.Mod) map[string]string {
	result := make(map[string]string)
	for _, m := range mods {
		for k, v := range m.Env {
			result[k] = v
		}
	}
	return result
}

// determineDefaultShell finds the last shell specified by mods
func determineDefaultShell(mods []*mod.Mod) string {
	shell := "bash" // default
	for _, m := range mods {
		if m.UserShell != "" {
			shell = m.UserShell
		}
	}
	return shell
}
