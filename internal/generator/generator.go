package generator

import (
	"fmt"
	"strings"

	"github.com/joelhelbling/glovebox/internal/assets"
	"github.com/joelhelbling/glovebox/internal/mod"
)

// GenerateBase creates a base Dockerfile from a list of mod IDs.
// This is used for the global profile and produces a standalone image.
func GenerateBase(modIDs []string) (string, error) {
	allMods, err := mod.LoadMultiple(modIDs)
	if err != nil {
		return "", fmt.Errorf("loading mods: %w", err)
	}

	// Separate build-time and post-install mods
	mods := filterBuildTimeMods(allMods)
	postInstallMods := filterPostInstallMods(allMods)

	var b strings.Builder

	// Header
	b.WriteString("# Generated by glovebox - DO NOT EDIT DIRECTLY\n")
	b.WriteString("#\n")
	b.WriteString("# This is the base image. To modify:\n")
	b.WriteString("#   glovebox add <mod>      Add a mod\n")
	b.WriteString("#   glovebox remove <mod>   Remove a mod\n")
	b.WriteString("#   glovebox build          Regenerate this file\n")
	b.WriteString("#\n")
	b.WriteString("# Build-time mods:\n")
	for _, m := range mods {
		b.WriteString(fmt.Sprintf("#   - %s\n", m.Name))
	}
	if len(postInstallMods) > 0 {
		b.WriteString("#\n")
		b.WriteString("# Post-install mods (installed on first run):\n")
		for _, m := range postInstallMods {
			b.WriteString(fmt.Sprintf("#   - %s\n", m.Name))
		}
	}
	b.WriteString("\n")

	// Base image
	b.WriteString("FROM ubuntu:24.04\n\n")

	// Avoid interactive prompts
	b.WriteString("# Avoid interactive prompts during package installation\n")
	b.WriteString("ENV DEBIAN_FRONTEND=noninteractive\n\n")

	// Collect and dedupe apt repos
	aptRepos := collectAptRepos(mods)
	if len(aptRepos) > 0 {
		// Need software-properties-common for apt-add-repository
		b.WriteString("# Install software-properties-common for apt-add-repository\n")
		b.WriteString("RUN apt-get update && apt-get install -y software-properties-common && rm -rf /var/lib/apt/lists/*\n\n")

		b.WriteString("# Add APT repositories\n")
		b.WriteString("RUN ")
		for i, repo := range aptRepos {
			if i > 0 {
				b.WriteString(" && \\\n    ")
			}
			b.WriteString(fmt.Sprintf("apt-add-repository %s", repo))
		}
		b.WriteString("\n\n")
	}

	// Collect and dedupe apt packages
	aptPackages := collectAptPackages(mods)
	if len(aptPackages) > 0 {
		b.WriteString("# Install packages\n")
		b.WriteString("RUN apt-get update && apt-get install -y \\\n")
		for i, pkg := range aptPackages {
			b.WriteString(fmt.Sprintf("    %s", pkg))
			if i < len(aptPackages)-1 {
				b.WriteString(" \\\n")
			} else {
				b.WriteString(" \\\n    && rm -rf /var/lib/apt/lists/*\n")
			}
		}
		b.WriteString("\n")
	}

	// Run as root commands (in mod order)
	for _, m := range mods {
		if m.RunAsRoot != "" {
			b.WriteString(fmt.Sprintf("# %s setup (root)\n", m.Name))
			b.WriteString("RUN <<'EOF'\n")
			b.WriteString("set -e\n")
			b.WriteString(strings.TrimSpace(m.RunAsRoot))
			b.WriteString("\nEOF\n\n")
		}
	}

	// Write entrypoint script inline using heredoc
	b.WriteString("# Create entrypoint script\n")
	b.WriteString("RUN cat > /usr/local/bin/entrypoint.sh <<'EOF'\n")
	b.WriteString(strings.TrimSpace(assets.EntrypointScript))
	b.WriteString("\nEOF\n")
	b.WriteString("RUN chmod 755 /usr/local/bin/entrypoint.sh\n\n")

	// Create post-install script directory and script
	b.WriteString("# Create post-install script for first-run provisioning\n")
	b.WriteString("RUN mkdir -p /usr/local/lib/glovebox\n")
	postInstallScript := GeneratePostInstallScript(allMods)
	b.WriteString("RUN cat > /usr/local/lib/glovebox/post-install.sh <<'EOF'\n")
	b.WriteString(postInstallScript)
	b.WriteString("EOF\n")
	b.WriteString("RUN chmod 755 /usr/local/lib/glovebox/post-install.sh\n\n")

	// Switch to non-root user
	b.WriteString("# Switch to non-root user\n")
	b.WriteString("USER ubuntu\n")
	b.WriteString("WORKDIR /home/ubuntu\n\n")

	// Run as user commands
	for _, m := range mods {
		if m.RunAsUser != "" {
			b.WriteString(fmt.Sprintf("# %s setup (user)\n", m.Name))
			b.WriteString("RUN <<'EOF'\n")
			b.WriteString("set -e\n")
			b.WriteString(strings.TrimSpace(m.RunAsUser))
			b.WriteString("\nEOF\n\n")
		}
	}

	// Environment variables
	envVars := collectEnvVars(mods)
	if len(envVars) > 0 {
		b.WriteString("# Environment variables\n")
		for key, value := range envVars {
			b.WriteString(fmt.Sprintf("ENV %s=%s\n", key, value))
		}
		b.WriteString("\n")
	}

	// PATH
	b.WriteString("# Ensure local binaries are in PATH\n")
	b.WriteString("ENV PATH=\"/home/ubuntu/.local/bin:/usr/local/bin:$PATH\"\n\n")

	// Working directory
	b.WriteString("# Set working directory for mounted projects\n")
	b.WriteString("WORKDIR /workspace\n\n")

	// Entrypoint and default command
	b.WriteString("# Use entrypoint to fix permissions on mounted volumes\n")
	b.WriteString("ENTRYPOINT [\"/usr/local/bin/entrypoint.sh\"]\n")

	// Determine default shell
	defaultShell := determineDefaultShell(mods)
	b.WriteString(fmt.Sprintf("CMD [\"%s\"]\n", defaultShell))

	return b.String(), nil
}

// GenerateProject creates a project Dockerfile that extends the base image.
// It only includes project-specific mods (additive to base).
// baseModIDs should contain the mods already installed in the base image,
// so their dependencies won't be redundantly included.
func GenerateProject(modIDs []string, baseModIDs []string) (string, error) {
	allMods, err := mod.LoadMultipleExcluding(modIDs, baseModIDs)
	if err != nil {
		return "", fmt.Errorf("loading mods: %w", err)
	}

	// Separate build-time and post-install mods
	mods := filterBuildTimeMods(allMods)
	postInstallMods := filterPostInstallMods(allMods)

	var b strings.Builder

	// Header
	b.WriteString("# Generated by glovebox - DO NOT EDIT DIRECTLY\n")
	b.WriteString("#\n")
	b.WriteString("# This extends glovebox:base with project-specific tools.\n")
	b.WriteString("# To modify:\n")
	b.WriteString("#   glovebox add <mod>      Add a mod\n")
	b.WriteString("#   glovebox remove <mod>   Remove a mod\n")
	b.WriteString("#   glovebox build          Regenerate this file\n")
	b.WriteString("#\n")
	if len(mods) > 0 {
		b.WriteString("# Build-time mods:\n")
		for _, m := range mods {
			b.WriteString(fmt.Sprintf("#   - %s\n", m.Name))
		}
	}
	if len(postInstallMods) > 0 {
		if len(mods) > 0 {
			b.WriteString("#\n")
		}
		b.WriteString("# Post-install mods (installed on first run):\n")
		for _, m := range postInstallMods {
			b.WriteString(fmt.Sprintf("#   - %s\n", m.Name))
		}
	}
	if len(mods) == 0 && len(postInstallMods) == 0 {
		b.WriteString("# (no project-specific mods)\n")
	}
	b.WriteString("\n")

	// Extend base image
	b.WriteString("FROM glovebox:base\n\n")

	// Switch to root for installations
	b.WriteString("USER root\n\n")

	// Collect and dedupe apt repos
	aptRepos := collectAptRepos(mods)
	if len(aptRepos) > 0 {
		// Need software-properties-common for apt-add-repository (may already be in base)
		b.WriteString("# Ensure software-properties-common is available for apt-add-repository\n")
		b.WriteString("RUN apt-get update && apt-get install -y software-properties-common && rm -rf /var/lib/apt/lists/*\n\n")

		b.WriteString("# Add APT repositories\n")
		b.WriteString("RUN ")
		for i, repo := range aptRepos {
			if i > 0 {
				b.WriteString(" && \\\n    ")
			}
			b.WriteString(fmt.Sprintf("apt-add-repository %s", repo))
		}
		b.WriteString("\n\n")
	}

	// Collect and dedupe apt packages
	aptPackages := collectAptPackages(mods)
	if len(aptPackages) > 0 {
		b.WriteString("# Install packages\n")
		b.WriteString("RUN apt-get update && apt-get install -y \\\n")
		for i, pkg := range aptPackages {
			b.WriteString(fmt.Sprintf("    %s", pkg))
			if i < len(aptPackages)-1 {
				b.WriteString(" \\\n")
			} else {
				b.WriteString(" \\\n    && rm -rf /var/lib/apt/lists/*\n")
			}
		}
		b.WriteString("\n")
	}

	// Run as root commands (in mod order)
	for _, m := range mods {
		if m.RunAsRoot != "" {
			b.WriteString(fmt.Sprintf("# %s setup (root)\n", m.Name))
			b.WriteString("RUN <<'EOF'\n")
			b.WriteString("set -e\n")
			b.WriteString(strings.TrimSpace(m.RunAsRoot))
			b.WriteString("\nEOF\n\n")
		}
	}

	// Switch back to non-root user
	b.WriteString("# Switch back to non-root user\n")
	b.WriteString("USER ubuntu\n")
	b.WriteString("WORKDIR /home/ubuntu\n\n")

	// Run as user commands
	for _, m := range mods {
		if m.RunAsUser != "" {
			b.WriteString(fmt.Sprintf("# %s setup (user)\n", m.Name))
			b.WriteString("RUN <<'EOF'\n")
			b.WriteString("set -e\n")
			b.WriteString(strings.TrimSpace(m.RunAsUser))
			b.WriteString("\nEOF\n\n")
		}
	}

	// Environment variables
	envVars := collectEnvVars(mods)
	if len(envVars) > 0 {
		b.WriteString("# Environment variables\n")
		for key, value := range envVars {
			b.WriteString(fmt.Sprintf("ENV %s=%s\n", key, value))
		}
		b.WriteString("\n")
	}

	// Update post-install script if there are project-specific post-install mods
	if len(postInstallMods) > 0 {
		b.WriteString("# Update post-install script with project-specific mods\n")
		b.WriteString("USER root\n")
		postInstallScript := GeneratePostInstallScript(allMods)
		b.WriteString("RUN cat > /usr/local/lib/glovebox/post-install.sh <<'EOF'\n")
		b.WriteString(postInstallScript)
		b.WriteString("EOF\n")
		b.WriteString("RUN chmod 755 /usr/local/lib/glovebox/post-install.sh\n")
		b.WriteString("USER ubuntu\n\n")
	}

	// Set working directory
	b.WriteString("# Set working directory for mounted projects\n")
	b.WriteString("WORKDIR /workspace\n")

	return b.String(), nil
}

// Generate creates a Dockerfile from a list of mod IDs (legacy, for base images)
// Deprecated: Use GenerateBase or GenerateProject instead
func Generate(modIDs []string) (string, error) {
	return GenerateBase(modIDs)
}

// collectAptRepos gathers unique apt repos from all mods
func collectAptRepos(mods []*mod.Mod) []string {
	seen := make(map[string]bool)
	var result []string
	for _, m := range mods {
		for _, repo := range m.AptRepos {
			if !seen[repo] {
				seen[repo] = true
				result = append(result, repo)
			}
		}
	}
	return result
}

// collectAptPackages gathers unique apt packages from all mods
func collectAptPackages(mods []*mod.Mod) []string {
	seen := make(map[string]bool)
	var result []string
	for _, m := range mods {
		for _, pkg := range m.AptPackages {
			if !seen[pkg] {
				seen[pkg] = true
				result = append(result, pkg)
			}
		}
	}
	return result
}

// collectEnvVars gathers environment variables, later mods override earlier
func collectEnvVars(mods []*mod.Mod) map[string]string {
	result := make(map[string]string)
	for _, m := range mods {
		for k, v := range m.Env {
			result[k] = v
		}
	}
	return result
}

// determineDefaultShell finds the last shell specified by mods
func determineDefaultShell(mods []*mod.Mod) string {
	shell := "bash" // default
	for _, m := range mods {
		if m.UserShell != "" {
			shell = m.UserShell
		}
	}
	return shell
}

// filterBuildTimeMods returns only mods that should be installed during docker build
func filterBuildTimeMods(mods []*mod.Mod) []*mod.Mod {
	var result []*mod.Mod
	for _, m := range mods {
		if m.IsBuildTime() {
			result = append(result, m)
		}
	}
	return result
}

// filterPostInstallMods returns only mods that should be installed on first run
func filterPostInstallMods(mods []*mod.Mod) []*mod.Mod {
	var result []*mod.Mod
	for _, m := range mods {
		if m.IsPostInstall() {
			result = append(result, m)
		}
	}
	return result
}

// GeneratePostInstallScript creates a shell script for first-run installation
func GeneratePostInstallScript(mods []*mod.Mod) string {
	postInstallMods := filterPostInstallMods(mods)

	var b strings.Builder

	b.WriteString("#!/bin/bash\n")
	b.WriteString("set -e\n\n")

	if len(postInstallMods) == 0 {
		b.WriteString("# No post-install mods configured\n")
		b.WriteString("exit 0\n")
		return b.String()
	}

	b.WriteString("echo \"\"\n")
	b.WriteString("echo \"===========================================\"\n")
	b.WriteString("echo \"Glovebox: First-run provisioning\"\n")
	b.WriteString("echo \"===========================================\"\n")
	b.WriteString("echo \"\"\n")
	b.WriteString("echo \"Installing tools you selected. This only\"\n")
	b.WriteString("echo \"happens on first run - subsequent starts\"\n")
	b.WriteString("echo \"will be instant.\"\n")
	b.WriteString("echo \"\"\n\n")

	total := len(postInstallMods)
	for i, m := range postInstallMods {
		b.WriteString(fmt.Sprintf("# %s\n", m.Name))
		b.WriteString(fmt.Sprintf("echo \"[%d/%d] Installing %s...\"\n", i+1, total, m.Name))

		if m.RunAsRoot != "" {
			b.WriteString("sudo bash <<'ROOTEOF'\n")
			b.WriteString("set -e\n")
			b.WriteString(strings.TrimSpace(m.RunAsRoot))
			b.WriteString("\nROOTEOF\n\n")
		}

		if m.RunAsUser != "" {
			b.WriteString(strings.TrimSpace(m.RunAsUser))
			b.WriteString("\n\n")
		}
	}

	b.WriteString("echo \"\"\n")
	b.WriteString("echo \"===========================================\"\n")
	b.WriteString("echo \"Provisioning complete!\"\n")
	b.WriteString("echo \"===========================================\"\n")
	b.WriteString("echo \"\"\n")

	return b.String()
}
