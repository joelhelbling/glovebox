package generator

import (
	"fmt"
	"sort"
	"strings"

	"github.com/joelhelbling/glovebox/internal/assets"
	"github.com/joelhelbling/glovebox/internal/mod"
)

// GenerateBase creates a base Dockerfile from a list of mod IDs.
// This is used for the global profile and produces a standalone image.
func GenerateBase(modIDs []string) (string, error) {
	mods, err := mod.LoadMultiple(modIDs)
	if err != nil {
		return "", fmt.Errorf("loading mods: %w", err)
	}

	// Validate mods and get OS mod
	osMod, err := mod.ValidateMods(mods)
	if err != nil {
		return "", fmt.Errorf("validating mods: %w", err)
	}
	if osMod == nil {
		return "", fmt.Errorf("no OS mod found; base image requires an OS mod (e.g., os/ubuntu)")
	}
	if osMod.DockerfileFrom == "" {
		return "", fmt.Errorf("OS mod %q does not specify dockerfile_from", osMod.Name)
	}

	var b strings.Builder

	// Header
	b.WriteString("# Generated by glovebox - DO NOT EDIT DIRECTLY\n")
	b.WriteString("#\n")
	b.WriteString("# This is the base image. To modify:\n")
	b.WriteString("#   glovebox add <mod>      Add a mod\n")
	b.WriteString("#   glovebox remove <mod>   Remove a mod\n")
	b.WriteString("#   glovebox build          Regenerate this file\n")
	b.WriteString("#\n")
	b.WriteString("# Mods:\n")
	for _, m := range mods {
		b.WriteString(fmt.Sprintf("#   - %s\n", m.Name))
	}
	b.WriteString("\n")

	// Base image from OS mod
	b.WriteString(fmt.Sprintf("FROM %s\n\n", osMod.DockerfileFrom))

	// Run as root commands (in mod order)
	for _, m := range mods {
		if m.RunAsRoot != "" {
			b.WriteString(fmt.Sprintf("# %s setup (root)\n", m.Name))
			b.WriteString("RUN <<'EOF'\n")
			b.WriteString("set -e\n")
			b.WriteString(strings.TrimSpace(m.RunAsRoot))
			b.WriteString("\nEOF\n\n")
		}
	}

	// Write entrypoint script inline using heredoc
	b.WriteString("# Create entrypoint script\n")
	b.WriteString("RUN cat > /usr/local/bin/entrypoint.sh <<'EOF'\n")
	b.WriteString(strings.TrimSpace(assets.EntrypointScript))
	b.WriteString("\nEOF\n")
	b.WriteString("RUN chmod 755 /usr/local/bin/entrypoint.sh\n\n")

	// Switch to non-root user
	b.WriteString("# Switch to non-root user\n")
	b.WriteString("USER ubuntu\n")
	b.WriteString("WORKDIR /home/ubuntu\n\n")

	// Environment variables - set before run_as_user so mods can use each other's env vars
	// (e.g., neovim needs homebrew's PATH to run `brew install`)
	envVars := collectEnvVars(mods)

	// Always include local bin paths
	b.WriteString("# Ensure local binaries are in PATH\n")
	if pathVal, hasPath := envVars["PATH"]; hasPath {
		// Prepend our paths to the mod-specified PATH
		b.WriteString(fmt.Sprintf("ENV PATH=\"/home/ubuntu/.local/bin:/usr/local/bin:%s\"\n", pathVal))
		delete(envVars, "PATH") // Don't emit again below
	} else {
		b.WriteString("ENV PATH=\"/home/ubuntu/.local/bin:/usr/local/bin:$PATH\"\n")
	}

	if len(envVars) > 0 {
		b.WriteString("# Environment variables from mods\n")
		// Sort keys for deterministic output
		envKeys := make([]string, 0, len(envVars))
		for key := range envVars {
			envKeys = append(envKeys, key)
		}
		sort.Strings(envKeys)
		for _, key := range envKeys {
			b.WriteString(fmt.Sprintf("ENV %s=%s\n", key, envVars[key]))
		}
	}
	b.WriteString("\n")

	// Run as user commands
	for _, m := range mods {
		if m.RunAsUser != "" {
			b.WriteString(fmt.Sprintf("# %s setup (user)\n", m.Name))
			b.WriteString("RUN <<'EOF'\n")
			b.WriteString("set -e\n")
			b.WriteString(strings.TrimSpace(m.RunAsUser))
			b.WriteString("\nEOF\n\n")
		}
	}

	// Working directory
	b.WriteString("# Set working directory for mounted projects\n")
	b.WriteString("WORKDIR /workspace\n\n")

	// Entrypoint and default command
	b.WriteString("# Use entrypoint for container initialization\n")
	b.WriteString("ENTRYPOINT [\"/usr/local/bin/entrypoint.sh\"]\n")

	// Determine default shell
	defaultShell := determineDefaultShell(mods)
	b.WriteString(fmt.Sprintf("CMD [\"%s\"]\n", defaultShell))

	return b.String(), nil
}

// GenerateProject creates a project Dockerfile that extends the base image.
// It only includes project-specific mods (additive to base).
// baseModIDs should contain the mods already installed in the base image,
// so their dependencies won't be redundantly included.
func GenerateProject(modIDs []string, baseModIDs []string) (string, error) {
	mods, err := mod.LoadMultipleExcluding(modIDs, baseModIDs)
	if err != nil {
		return "", fmt.Errorf("loading mods: %w", err)
	}

	var b strings.Builder

	// Header
	b.WriteString("# Generated by glovebox - DO NOT EDIT DIRECTLY\n")
	b.WriteString("#\n")
	b.WriteString("# This extends glovebox:base with project-specific tools.\n")
	b.WriteString("# To modify:\n")
	b.WriteString("#   glovebox add <mod>      Add a mod\n")
	b.WriteString("#   glovebox remove <mod>   Remove a mod\n")
	b.WriteString("#   glovebox build          Regenerate this file\n")
	b.WriteString("#\n")
	if len(mods) > 0 {
		b.WriteString("# Mods:\n")
		for _, m := range mods {
			b.WriteString(fmt.Sprintf("#   - %s\n", m.Name))
		}
	} else {
		b.WriteString("# (no project-specific mods)\n")
	}
	b.WriteString("\n")

	// Extend base image
	b.WriteString("FROM glovebox:base\n\n")

	// Switch to root for installations
	b.WriteString("USER root\n\n")

	// Run as root commands (in mod order)
	for _, m := range mods {
		if m.RunAsRoot != "" {
			b.WriteString(fmt.Sprintf("# %s setup (root)\n", m.Name))
			b.WriteString("RUN <<'EOF'\n")
			b.WriteString("set -e\n")
			b.WriteString(strings.TrimSpace(m.RunAsRoot))
			b.WriteString("\nEOF\n\n")
		}
	}

	// Switch back to non-root user
	b.WriteString("# Switch back to non-root user\n")
	b.WriteString("USER ubuntu\n")
	b.WriteString("WORKDIR /home/ubuntu\n\n")

	// Environment variables - set before run_as_user so mods can use each other's env vars
	envVars := collectEnvVars(mods)
	if len(envVars) > 0 {
		b.WriteString("# Environment variables from mods\n")
		// Sort keys for deterministic output
		envKeys := make([]string, 0, len(envVars))
		for key := range envVars {
			envKeys = append(envKeys, key)
		}
		sort.Strings(envKeys)
		for _, key := range envKeys {
			b.WriteString(fmt.Sprintf("ENV %s=%s\n", key, envVars[key]))
		}
		b.WriteString("\n")
	}

	// Run as user commands
	for _, m := range mods {
		if m.RunAsUser != "" {
			b.WriteString(fmt.Sprintf("# %s setup (user)\n", m.Name))
			b.WriteString("RUN <<'EOF'\n")
			b.WriteString("set -e\n")
			b.WriteString(strings.TrimSpace(m.RunAsUser))
			b.WriteString("\nEOF\n\n")
		}
	}

	// Set working directory
	b.WriteString("# Set working directory for mounted projects\n")
	b.WriteString("WORKDIR /workspace\n")

	return b.String(), nil
}

// collectEnvVars gathers environment variables, later mods override earlier
func collectEnvVars(mods []*mod.Mod) map[string]string {
	result := make(map[string]string)
	for _, m := range mods {
		for k, v := range m.Env {
			result[k] = v
		}
	}
	return result
}

// determineDefaultShell finds the last shell specified by mods
func determineDefaultShell(mods []*mod.Mod) string {
	shell := "bash" // default
	for _, m := range mods {
		if m.UserShell != "" {
			shell = m.UserShell
		}
	}
	return shell
}
