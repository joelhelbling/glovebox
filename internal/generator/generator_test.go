package generator

import (
	"strings"
	"testing"

	"github.com/joelhelbling/glovebox/internal/mod"
)

func TestCollectEnvVars(t *testing.T) {
	t.Run("empty mods", func(t *testing.T) {
		result := collectEnvVars([]*mod.Mod{})
		if len(result) != 0 {
			t.Errorf("expected empty result, got %d items", len(result))
		}
	})

	t.Run("single mod with env vars", func(t *testing.T) {
		mods := []*mod.Mod{
			{Name: "test", Env: map[string]string{"FOO": "bar"}},
		}
		result := collectEnvVars(mods)
		if result["FOO"] != "bar" {
			t.Errorf("expected FOO=bar, got FOO=%q", result["FOO"])
		}
	})

	t.Run("later mods override earlier", func(t *testing.T) {
		mods := []*mod.Mod{
			{Name: "mod1", Env: map[string]string{"PATH": "/first"}},
			{Name: "mod2", Env: map[string]string{"PATH": "/second"}},
		}
		result := collectEnvVars(mods)
		if result["PATH"] != "/second" {
			t.Errorf("expected PATH=/second (override), got PATH=%q", result["PATH"])
		}
	})

	t.Run("merges non-conflicting vars", func(t *testing.T) {
		mods := []*mod.Mod{
			{Name: "mod1", Env: map[string]string{"A": "1"}},
			{Name: "mod2", Env: map[string]string{"B": "2"}},
		}
		result := collectEnvVars(mods)
		if result["A"] != "1" || result["B"] != "2" {
			t.Errorf("expected A=1 and B=2, got %v", result)
		}
	})
}

func TestDetermineDefaultShell(t *testing.T) {
	t.Run("no shell specified returns bash", func(t *testing.T) {
		mods := []*mod.Mod{
			{Name: "ubuntu", Category: "os"},
		}
		result := determineDefaultShell(mods)
		if result != "bash" {
			t.Errorf("expected 'bash' default, got %q", result)
		}
	})

	t.Run("uses specified shell", func(t *testing.T) {
		mods := []*mod.Mod{
			{Name: "fish", UserShell: "/usr/bin/fish"},
		}
		result := determineDefaultShell(mods)
		if result != "/usr/bin/fish" {
			t.Errorf("expected '/usr/bin/fish', got %q", result)
		}
	})

	t.Run("last shell wins", func(t *testing.T) {
		mods := []*mod.Mod{
			{Name: "bash", UserShell: "bash"},
			{Name: "zsh", UserShell: "zsh"},
			{Name: "fish", UserShell: "fish"},
		}
		result := determineDefaultShell(mods)
		if result != "fish" {
			t.Errorf("expected 'fish' (last), got %q", result)
		}
	})

	t.Run("empty mods returns bash", func(t *testing.T) {
		result := determineDefaultShell([]*mod.Mod{})
		if result != "bash" {
			t.Errorf("expected 'bash' default, got %q", result)
		}
	})
}

func TestGenerateBase(t *testing.T) {
	t.Run("generates valid Dockerfile with OS mod", func(t *testing.T) {
		dockerfile, err := GenerateBase([]string{"os/ubuntu"})
		if err != nil {
			t.Fatalf("GenerateBase() error = %v", err)
		}

		// Check for required Dockerfile elements
		checks := []struct {
			name    string
			content string
		}{
			{"header comment", "# Generated by glovebox"},
			{"base image from OS mod", "FROM ubuntu:24.04"},
			{"user switch", "USER dev"},
			{"workdir", "WORKDIR /workspace"},
			{"entrypoint", "ENTRYPOINT"},
		}

		for _, check := range checks {
			if !strings.Contains(dockerfile, check.content) {
				t.Errorf("expected Dockerfile to contain %s (%q)", check.name, check.content)
			}
		}
	})

	t.Run("includes run_as_root from mods", func(t *testing.T) {
		dockerfile, err := GenerateBase([]string{"os/ubuntu"})
		if err != nil {
			t.Fatalf("GenerateBase() error = %v", err)
		}

		// OS mod should include core package installation
		if !strings.Contains(dockerfile, "apt-get") {
			t.Error("expected Dockerfile to include apt-get commands from run_as_root")
		}
		if !strings.Contains(dockerfile, "curl") {
			t.Error("expected Dockerfile to include 'curl' package")
		}
	})

	t.Run("includes dependency mods", func(t *testing.T) {
		// homebrew-ubuntu requires ubuntu, which os/ubuntu provides
		dockerfile, err := GenerateBase([]string{"os/ubuntu", "tools/homebrew-ubuntu"})
		if err != nil {
			t.Fatalf("GenerateBase() error = %v", err)
		}

		// Should include homebrew setup
		if !strings.Contains(dockerfile, "homebrew") || !strings.Contains(dockerfile, "Homebrew") {
			t.Error("expected Dockerfile to include homebrew setup comments")
		}
	})

	t.Run("fails for non-existent mod", func(t *testing.T) {
		_, err := GenerateBase([]string{"nonexistent/fake"})
		if err == nil {
			t.Error("expected error for non-existent mod")
		}
	})

	t.Run("fails without OS mod", func(t *testing.T) {
		// shells/bash requires base but no OS mod provides it
		_, err := GenerateBase([]string{"shells/bash"})
		if err == nil {
			t.Error("expected error when no OS mod present")
		}
		// Error could be about missing base provider or no OS mod
		if !strings.Contains(err.Error(), "no OS mod found") && !strings.Contains(err.Error(), "nothing provides") {
			t.Errorf("expected 'no OS mod found' or 'nothing provides' error, got: %v", err)
		}
	})

	t.Run("sets default shell to bash", func(t *testing.T) {
		dockerfile, err := GenerateBase([]string{"os/ubuntu"})
		if err != nil {
			t.Fatalf("GenerateBase() error = %v", err)
		}

		if !strings.Contains(dockerfile, `CMD ["bash"]`) {
			t.Error("expected CMD [\"bash\"] for default shell")
		}
	})
}

func TestGenerateProject(t *testing.T) {
	t.Run("extends base image", func(t *testing.T) {
		dockerfile, err := GenerateProject([]string{"tools/mise"}, []string{"os/ubuntu", "tools/homebrew-ubuntu"})
		if err != nil {
			t.Fatalf("GenerateProject() error = %v", err)
		}

		if !strings.Contains(dockerfile, "FROM glovebox:base") {
			t.Error("expected Dockerfile to extend glovebox:base")
		}
	})

	t.Run("excludes base mods", func(t *testing.T) {
		// mise requires base (provided by os/ubuntu)
		// If os/ubuntu is in baseModIDs, only mise should be in output
		dockerfile, err := GenerateProject([]string{"tools/mise"}, []string{"os/ubuntu"})
		if err != nil {
			t.Fatalf("GenerateProject() error = %v", err)
		}

		// Should include mise setup
		if !strings.Contains(dockerfile, "mise") {
			t.Error("expected Dockerfile to include mise setup")
		}
	})

	t.Run("switches to root then back to dev", func(t *testing.T) {
		dockerfile, err := GenerateProject([]string{"editors/neovim-ubuntu"}, []string{"os/ubuntu"})
		if err != nil {
			t.Fatalf("GenerateProject() error = %v", err)
		}

		// Should switch to root for installations
		if !strings.Contains(dockerfile, "USER root") {
			t.Error("expected USER root for installations")
		}

		// Should switch back to dev
		if !strings.Contains(dockerfile, "USER dev") {
			t.Error("expected USER dev after installations")
		}
	})

	t.Run("empty mods produces minimal Dockerfile", func(t *testing.T) {
		dockerfile, err := GenerateProject([]string{}, []string{"os/ubuntu"})
		if err != nil {
			t.Fatalf("GenerateProject() error = %v", err)
		}

		if !strings.Contains(dockerfile, "# (no project-specific mods)") {
			t.Error("expected comment about no project-specific mods")
		}
	})
}

func TestDockerfileStructure(t *testing.T) {
	t.Run("instructions in correct order", func(t *testing.T) {
		dockerfile, err := GenerateBase([]string{"os/ubuntu"})
		if err != nil {
			t.Fatalf("GenerateBase() error = %v", err)
		}

		// Check that key instructions appear in correct order
		fromIdx := strings.Index(dockerfile, "FROM")
		runIdx := strings.Index(dockerfile, "RUN")
		userIdx := strings.Index(dockerfile, "USER dev")
		workdirIdx := strings.Index(dockerfile, "WORKDIR /workspace")
		entrypointIdx := strings.Index(dockerfile, "ENTRYPOINT")
		cmdIdx := strings.Index(dockerfile, "CMD")

		if fromIdx > runIdx {
			t.Error("FROM should come before RUN")
		}
		if runIdx > userIdx {
			t.Error("RUN should come before USER dev")
		}
		if userIdx > workdirIdx {
			t.Error("USER dev should come before WORKDIR /workspace")
		}
		if workdirIdx > entrypointIdx {
			t.Error("WORKDIR should come before ENTRYPOINT")
		}
		if entrypointIdx > cmdIdx {
			t.Error("ENTRYPOINT should come before CMD")
		}
	})
}

func TestEnvVarsInDockerfile(t *testing.T) {
	t.Run("homebrew sets PATH", func(t *testing.T) {
		dockerfile, err := GenerateBase([]string{"os/ubuntu", "tools/homebrew-ubuntu"})
		if err != nil {
			t.Fatalf("GenerateBase() error = %v", err)
		}

		// Homebrew should add its bin to PATH
		if !strings.Contains(dockerfile, "linuxbrew") {
			t.Error("expected Dockerfile to include linuxbrew paths")
		}
	})
}

func TestOSModValidation(t *testing.T) {
	t.Run("OS mod provides dockerfile_from", func(t *testing.T) {
		dockerfile, err := GenerateBase([]string{"os/ubuntu"})
		if err != nil {
			t.Fatalf("GenerateBase() error = %v", err)
		}

		// Should use ubuntu:24.04 from the OS mod
		if !strings.Contains(dockerfile, "FROM ubuntu:24.04") {
			t.Error("expected FROM to use dockerfile_from from OS mod")
		}
	})

	t.Run("OS mod provides base for dependencies", func(t *testing.T) {
		// homebrew-ubuntu requires ubuntu, os/ubuntu provides ubuntu
		_, err := GenerateBase([]string{"os/ubuntu", "tools/homebrew-ubuntu"})
		if err != nil {
			t.Errorf("expected os/ubuntu to satisfy base requirement: %v", err)
		}
	})
}
