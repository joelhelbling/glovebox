---
import DocsLayout from '../../../layouts/DocsLayout.astro';
import Prose from '../../../components/Prose.astro';
---

<DocsLayout
  title="Architecture"
  description="How layered images and persistence work"
  section="architecture"
  order={5}
>
  <Prose>
    <p>Glovebox uses a layered image approach with persistent containers to balance reproducibility with flexibility.</p>

    <h2>Layered Images</h2>
    <pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     Project Image           â”‚  â† Project-specific tools
â”‚  (glovebox:myproject-abc123)â”‚     FROM glovebox:base
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚     Base Image              â”‚  â† Your standard environment
â”‚     (glovebox:base)         â”‚     Shell, editor, mise, etc.
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Ubuntu / Fedora / Alpine   â”‚  â† Choose your base OS
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre>

    <h3>Base Image (<code>glovebox:base</code>)</h3>
    <p>Your standard development environment, defined in <code>~/.glovebox/profile.yaml</code>. Contains your preferred:</p>
    <ul>
      <li>Shell (bash, zsh, fish)</li>
      <li>Editor (vim, neovim, helix, emacs)</li>
      <li>Common tools (mise, tmux, homebrew)</li>
      <li>AI assistants (claude-code, gemini-cli, opencode)</li>
    </ul>
    <p>Build once with <code>glovebox build --base</code>, then use across all projects.</p>

    <h3>Project Images</h3>
    <p>Optional project-specific extensions defined in <code>.glovebox/profile.yaml</code>. These images:</p>
    <ul>
      <li>Extend <code>glovebox:base</code> (using <code>FROM glovebox:base</code>)</li>
      <li>Add only the tools needed for that specific project</li>
      <li>Are tagged as <code>glovebox:&lt;dirname&gt;-&lt;hash&gt;</code></li>
    </ul>
    <p>Most projects don't need a project imageâ€”the base image is sufficient.</p>

    <h2>Container Persistence</h2>
    <p>Each project gets its own persistent container. Glovebox does not use <code>--rm</code>.</p>

    <h3>Container Lifecycle</h3>
    <ol>
      <li><strong>First run:</strong> Creates a new container from your image</li>
      <li><strong>Subsequent runs:</strong> Starts the existing container (preserving all changes)</li>
      <li><strong>On exit:</strong> Shows a summary of any filesystem changes</li>
    </ol>
    <p>This means you can install tools, configure editors, and customize your environment during a sessionâ€”then decide later whether to persist those changes.</p>

    <h3>Exit Workflow</h3>
    <p>When you exit a Glovebox session, it detects changes and shows a summary:</p>
    <pre><code>dev@glovebox /workspace (main)> brew install yq
ğŸº  /home/linuxbrew/.linuxbrew/Cellar/yq/4.50.1: 10 files, 13MB

dev@glovebox /workspace (main)> exit

  â”ƒ Session ended Â· container has uncommitted changes:
  â”ƒ
  â”ƒ   brew install yq
  â”ƒ   added /home/linuxbrew/.linuxbrew/var/homebrew/tmp
  â”ƒ   modified /home/linuxbrew/.linuxbrew/var/homebrew/linked
  â”ƒ   added /home/linuxbrew/.linuxbrew/var/homebrew/linked/yq
  â”ƒ   ...and 20 more changes
  â”ƒ
  â”ƒ To persist: glovebox commit
  â”ƒ To discard: glovebox reset</code></pre>
    <p>Your changes remain in the container until you decide what to do with them.</p>

    <h3>Commands</h3>
    <table>
      <thead>
        <tr><th>Command</th><th>Container</th><th>Image</th><th>Next Run</th></tr>
      </thead>
      <tbody>
        <tr><td><code>glovebox commit</code></td><td>Removed</td><td>Updated</td><td>Fresh container from updated image</td></tr>
        <tr><td><code>glovebox reset</code></td><td>Removed</td><td>Unchanged</td><td>Fresh container from original image</td></tr>
        <tr><td><em>(do nothing)</em></td><td>Preserved</td><td>Unchanged</td><td>Resume same container with changes</td></tr>
      </tbody>
    </table>

    <h3>When to Commit vs. Reset</h3>
    <p><strong>Commit</strong> when you've installed something you want permanently:</p>
    <ul>
      <li>New CLI tools (<code>brew install jq</code>)</li>
      <li>Editor plugins</li>
      <li>Configuration changes you want to keep</li>
    </ul>
    <p><strong>Do nothing</strong> when you're still experimenting:</p>
    <ul>
      <li>Trying out a tool you're not sure about</li>
      <li>Making temporary configuration changes</li>
      <li>Debugging with extra packages installed</li>
    </ul>
    <p><strong>Reset</strong> when something went wrong:</p>
    <ul>
      <li>Broke your configuration</li>
      <li>Installed something that conflicts</li>
      <li>Want a clean slate</li>
    </ul>

    <h2>Design Philosophy</h2>
    <p>Glovebox balances two concerns:</p>
    <ol>
      <li><strong>Declarative base:</strong> Mods in your profile define your standard environment, baked into images at build time</li>
      <li><strong>Flexible runtime:</strong> Ad-hoc changes during sessions can be committed back to the image</li>
    </ol>
    <table>
      <thead>
        <tr><th>What</th><th>How</th><th>When</th></tr>
      </thead>
      <tbody>
        <tr><td>Shells, editors, tools</td><td>Mods in profile</td><td>Build time</td></tr>
        <tr><td>Language runtimes</td><td>Mise (via mod)</td><td>Build time</td></tr>
        <tr><td>Ad-hoc installs</td><td>Commit workflow</td><td>Runtime</td></tr>
        <tr><td>Your code</td><td>Mounted from host</td><td>Always current</td></tr>
      </tbody>
    </table>

    <h3>Source of Truth</h3>
    <p>Your profile defines what <em>should</em> be installed. The container's writable layer captures any runtime additions.</p>
    <p>If you <code>glovebox clean --all</code> and rebuild, you get exactly what your profile specifiesâ€”nothing more, nothing less.</p>

    <h3>Why Not Just Use Mods for Everything?</h3>
    <p>Mods are great for tools you know you want. But development is exploratory:</p>
    <ul>
      <li>You discover you need <code>jq</code> to parse some API response</li>
      <li>You want to try <code>htop</code> to debug a performance issue</li>
      <li>You install a language server for a file type you rarely edit</li>
    </ul>
    <p>The commit workflow lets you capture these discoveries without editing YAML files mid-session. If the tool proves useful, you can later add a proper mod for it.</p>

    <h2>Security Model</h2>
    <p>Glovebox provides isolation, not invulnerability:</p>
    <ul>
      <li><strong>Container boundary:</strong> Your host filesystem is protected from rogue code</li>
      <li><strong>Mounted workspace:</strong> Your project files are accessible (read/write)</li>
      <li><strong>Network access:</strong> Containers have normal network access by default</li>
    </ul>
    <p>Think of it as a blast radius limiter. If an npm package or AI agent goes rogue, the damage is contained to the container. Your host system, SSH keys, and other projects remain safe.</p>
    <p>What Glovebox does <em>not</em> provide:</p>
    <ul>
      <li>Protection against container escape exploits</li>
      <li>Network isolation</li>
      <li>Resource limits (CPU, memory)</li>
    </ul>
    <p>For higher security needs, consider running Glovebox inside a VM.</p>
  </Prose>
</DocsLayout>
